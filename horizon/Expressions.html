<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.9&nbsp;Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins_and_Libraries.html" class="tocviewlink" data-pltdoc="x">Builtins and Libraries</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="type-check.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_literals.html" class="tocviewlink" data-pltdoc="x">Primitives and Literals</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="Bindings.html" class="tocviewlink" data-pltdoc="x">Bindings</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="Declarations.html" class="tocviewlink" data-pltdoc="x">Declarations</a></td></tr><tr><td align="right">2.1.8&nbsp;</td><td><a href="Statements.html" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.10&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.9.1&nbsp;</td><td><a href="#%28part._s~3alam-expr%29" class="tocviewlink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td align="right">2.1.9.2&nbsp;</td><td><a href="#%28part._s~3acurly-lam-expr%29" class="tocviewlink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td align="right">2.1.9.3&nbsp;</td><td><a href="#%28part._s~3amethod-expr%29" class="tocviewlink" data-pltdoc="x">Anonymous Method Expressions</a></td></tr><tr><td align="right">2.1.9.4&nbsp;</td><td><a href="#%28part._s~3aapp-expr%29" class="tocviewlink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td align="right">2.1.9.5&nbsp;</td><td><a href="#%28part._s~3acurried-apply-expr%29" class="tocviewlink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td align="right">2.1.9.6&nbsp;</td><td><a href="#%28part._s~3acannonball-expr%29" class="tocviewlink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td align="right">2.1.9.7&nbsp;</td><td><a href="#%28part._s~3ainst-expr%29" class="tocviewlink" data-pltdoc="x">Instantiation Expressions</a></td></tr><tr><td align="right">2.1.9.8&nbsp;</td><td><a href="#%28part._s~3abinop-expr%29" class="tocviewlink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td align="right">2.1.9.9&nbsp;</td><td><a href="#%28part._s~3atuple-expr%29" class="tocviewlink" data-pltdoc="x">Tuple Expressions</a></td></tr><tr><td align="right">2.1.9.10&nbsp;</td><td><a href="#%28part._s~3atuple-get-expr%29" class="tocviewlink" data-pltdoc="x">Tuple Access Expressions</a></td></tr><tr><td align="right">2.1.9.11&nbsp;</td><td><a href="#%28part._s~3aobj-expr%29" class="tocviewlink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td align="right">2.1.9.12&nbsp;</td><td><a href="#%28part._s~3adot-expr%29" class="tocviewlink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td align="right">2.1.9.13&nbsp;</td><td><a href="#%28part._s~3aextend-expr%29" class="tocviewlink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td align="right">2.1.9.14&nbsp;</td><td><a href="#%28part._s~3aif-expr%29" class="tocviewlink" data-pltdoc="x">If Expressions</a></td></tr><tr><td align="right">2.1.9.15&nbsp;</td><td><a href="#%28part._s~3aask-expr%29" class="tocviewlink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td align="right">2.1.9.16&nbsp;</td><td><a href="#%28part._s~3acases-expr%29" class="tocviewlink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td align="right">2.1.9.17&nbsp;</td><td><a href="#%28part._s~3afor-expr%29" class="tocviewlink" data-pltdoc="x">For Expressions</a></td></tr><tr><td align="right">2.1.9.18&nbsp;</td><td><a href="#%28part._s~3atemplate-expr%29" class="tocviewlink" data-pltdoc="x">Template (...) Expressions</a></td></tr><tr><td align="right">2.1.9.19&nbsp;</td><td><a href="#%28part._s~3atables%29" class="tocviewlink" data-pltdoc="x">Tables</a></td></tr><tr><td align="right">2.1.9.20&nbsp;</td><td><a href="#%28part._s~3atable-loading%29" class="tocviewlink" data-pltdoc="x">Table Loading Expressions</a></td></tr><tr><td align="right">2.1.9.21&nbsp;</td><td><a href="#%28part._s~3areactor-expr%29" class="tocviewlink" data-pltdoc="x">Reactor Expressions</a></td></tr><tr><td align="right">2.1.9.22&nbsp;</td><td><a href="#%28part._s~3areference-fields%29" class="tocviewlink" data-pltdoc="x">Mutable fields</a></td></tr><tr><td align="right">2.1.9.23&nbsp;</td><td><a href="#%28part._s~3aconstruct-expr%29" class="tocviewlink" data-pltdoc="x">Construction expressions</a></td></tr><tr><td align="right">2.1.9.24&nbsp;</td><td><a href="#%28part._s~3abinding-expressions%29" class="tocviewlink" data-pltdoc="x">Expression forms of bindings</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.9.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alam-expr%29" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.2<tt>&nbsp;</tt></span><a href="#%28part._s~3acurly-lam-expr%29" class="tocsubseclink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.3<tt>&nbsp;</tt></span><a href="#%28part._s~3amethod-expr%29" class="tocsubseclink" data-pltdoc="x">Anonymous Method Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.4<tt>&nbsp;</tt></span><a href="#%28part._s~3aapp-expr%29" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.5<tt>&nbsp;</tt></span><a href="#%28part._s~3acurried-apply-expr%29" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.6<tt>&nbsp;</tt></span><a href="#%28part._s~3acannonball-expr%29" class="tocsubseclink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.7<tt>&nbsp;</tt></span><a href="#%28part._s~3ainst-expr%29" class="tocsubseclink" data-pltdoc="x">Instantiation Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.8<tt>&nbsp;</tt></span><a href="#%28part._s~3abinop-expr%29" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.9<tt>&nbsp;</tt></span><a href="#%28part._s~3atuple-expr%29" class="tocsubseclink" data-pltdoc="x">Tuple Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.10<tt>&nbsp;</tt></span><a href="#%28part._s~3atuple-get-expr%29" class="tocsubseclink" data-pltdoc="x">Tuple Access Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.11<tt>&nbsp;</tt></span><a href="#%28part._s~3aobj-expr%29" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.12<tt>&nbsp;</tt></span><a href="#%28part._s~3adot-expr%29" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.13<tt>&nbsp;</tt></span><a href="#%28part._s~3aextend-expr%29" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.14<tt>&nbsp;</tt></span><a href="#%28part._s~3aif-expr%29" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.15<tt>&nbsp;</tt></span><a href="#%28part._s~3aask-expr%29" class="tocsubseclink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.16<tt>&nbsp;</tt></span><a href="#%28part._s~3acases-expr%29" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.17<tt>&nbsp;</tt></span><a href="#%28part._s~3afor-expr%29" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.18<tt>&nbsp;</tt></span><a href="#%28part._s~3atemplate-expr%29" class="tocsubseclink" data-pltdoc="x">Template (...) Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19<tt>&nbsp;</tt></span><a href="#%28part._s~3atables%29" class="tocsubseclink" data-pltdoc="x">Tables</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.1<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3aselect%29" class="tocsubseclink" data-pltdoc="x">Selecting Table Rows</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.2<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3afilter%29" class="tocsubseclink" data-pltdoc="x">Filtering Table Rows</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.3<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3aorder%29" class="tocsubseclink" data-pltdoc="x">Sorting Table Rows</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.4<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3atransform%29" class="tocsubseclink" data-pltdoc="x">Transforming Table Rows</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.5<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3aextract%29" class="tocsubseclink" data-pltdoc="x">Extracting Table Columns</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.19.6<tt>&nbsp;</tt></span><a href="#%28part._s~3atables~3aextend%29" class="tocsubseclink" data-pltdoc="x">Adding Table Columns</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.20<tt>&nbsp;</tt></span><a href="#%28part._s~3atable-loading%29" class="tocsubseclink" data-pltdoc="x">Table Loading Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.21<tt>&nbsp;</tt></span><a href="#%28part._s~3areactor-expr%29" class="tocsubseclink" data-pltdoc="x">Reactor Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.22<tt>&nbsp;</tt></span><a href="#%28part._s~3areference-fields%29" class="tocsubseclink" data-pltdoc="x">Mutable fields</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.23<tt>&nbsp;</tt></span><a href="#%28part._s~3aconstruct-expr%29" class="tocsubseclink" data-pltdoc="x">Construction expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.24<tt>&nbsp;</tt></span><a href="#%28part._s~3abinding-expressions%29" class="tocsubseclink" data-pltdoc="x">Expression forms of bindings</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.8 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.10 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.9<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><p>The following are all the expression forms of Pyret:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._expr)))"></a>&#8249;expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._paren-expr%29%29%29" data-pltdoc="x">&#8249;paren-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._id-expr%29%29%29" data-pltdoc="x">&#8249;id-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._prim-expr%29%29%29" data-pltdoc="x">&#8249;prim-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._lam-expr%29%29%29" data-pltdoc="x">&#8249;lam-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-expr%29%29%29" data-pltdoc="x">&#8249;app-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._obj-expr%29%29%29" data-pltdoc="x">&#8249;obj-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._dot-expr%29%29%29" data-pltdoc="x">&#8249;dot-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._extend-expr%29%29%29" data-pltdoc="x">&#8249;extend-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-expr%29%29%29" data-pltdoc="x">&#8249;tuple-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-get%29%29%29" data-pltdoc="x">&#8249;tuple-get&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._template-expr%29%29%29" data-pltdoc="x">&#8249;template-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._get-bang-expr%29%29%29" data-pltdoc="x">&#8249;get-bang-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._update-expr%29%29%29" data-pltdoc="x">&#8249;update-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._if-expr%29%29%29" data-pltdoc="x">&#8249;if-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-expr%29%29%29" data-pltdoc="x">&#8249;ask-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-expr%29%29%29" data-pltdoc="x">&#8249;cases-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-expr%29%29%29" data-pltdoc="x">&#8249;for-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._user-block-expr%29%29%29" data-pltdoc="x">&#8249;user-block-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._inst-expr%29%29%29" data-pltdoc="x">&#8249;inst-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._construct-expr%29%29%29" data-pltdoc="x">&#8249;construct-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._multi-let-expr%29%29%29" data-pltdoc="x">&#8249;multi-let-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._letrec-expr%29%29%29" data-pltdoc="x">&#8249;letrec-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._type-let-expr%29%29%29" data-pltdoc="x">&#8249;type-let-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._construct-expr%29%29%29" data-pltdoc="x">&#8249;construct-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-expr%29%29%29" data-pltdoc="x">&#8249;table-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-select%29%29%29" data-pltdoc="x">&#8249;table-select&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-sieve%29%29%29" data-pltdoc="x">&#8249;table-sieve&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-order%29%29%29" data-pltdoc="x">&#8249;table-order&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-extract%29%29%29" data-pltdoc="x">&#8249;table-extract&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-transform%29%29%29" data-pltdoc="x">&#8249;table-transform&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-extend%29%29%29" data-pltdoc="x">&#8249;table-extend&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._load-table-expr%29%29%29" data-pltdoc="x">&#8249;load-table-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._reactor-expr%29%29%29" data-pltdoc="x">&#8249;reactor-expr&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._paren-expr)))"></a>&#8249;paren-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._id-expr)))"></a>&#8249;id-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span>
<a name="(elem._(bnf-prod._(.Pyret._prim-expr)))"></a>&#8249;prim-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NUMBER</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">RATIONAL</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">BOOLEAN</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">STRING</span></p></blockquote><h5>2.1.9.1<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._lam-expr)))"></a>&#8249;lam-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">lam</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="Declarations.html#%28part._s~3alet-decl%29" data-pltdoc="x">let expression</a>.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  f = lam(x, y): x - y end
  f(5, 3) is 2
end

check:
  f = lam({x;y}): x - y end
  f({5;3}) is 2
end</p></pre></pre></div></p></div><p>These identifiers follow the same rules of no shadowing and no assignment.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>x = 12
f = lam(x): x end  # ERROR: x shadows a previous definition
g = lam(y):
  y := 10   # ERROR: y is not a variable and cannot be assigned
  y + 1
end</p></pre></pre></div></p></div><p>If the arguments have <a href="s_annotations.html" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><pre class="pyret-block"><pre class="pyret-highlight"><p>add1 = lam(x :: Number):
  x + 1
end
add1("not-a-number")
# Error: expected a Number and got "not-a-number"</p></pre></pre><p>A lambda expression can have a <span style="font-style: italic">return</span> annotation as well, which is
checked before evaluating to the final value:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>add1 = lam(x) -&gt; Number:
  tostring(x) + "1"
end
add1(5)
# Error: expected a Number and got "51"</p></pre></pre></div></p></div><p>Lambda expressions remember, or close over, the values of other identifiers
that are in scope when they are defined.  So, for example:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  x = 10
  f = lam(y): y + x end
  f(5) is 15
end</p></pre></pre></div></p></div><h5>2.1.9.2<tt>&nbsp;</tt><a name="(part._s~3acurly-lam-expr)"></a>Curly-Brace Lambda Shorthand</h5><p>Lambda expressions can also be written with a curly-brace shorthand:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">curly-lambda-expr: "{" ty-params [args] return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"}"</span></p></td></tr></table></blockquote><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  x = 10
  f = {(y :: Number) -&gt; Number: x + y}
  f(5) is 15
end</p></pre></pre></div></p></div><h5>2.1.9.3<tt>&nbsp;</tt><a name="(part._s~3amethod-expr)"></a>Anonymous Method Expressions</h5><p>An anonymous method expression looks much like an anonymous function (defined
with <span class="pyret-highlight"><span class="stt">lam</span></span>):</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._method-expr)))"></a>&#8249;method-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">method</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>All the same rules for bindings, including annotations and shadowing, apply the
same to <a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a>s as they do to <a href="#%28elem._%28bnf-prod._%28.Pyret._lam-expr%29%29%29" data-pltdoc="x">&#8249;lam-expr&#8250;</a>s.</p><p>It is a well-formedness error for a method to have no arguments.</p><p>At runtime, a <a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a> evaluates to a method value.  Method values
cannot be applied directly:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  m = method(self): self end
  m(5) raises "non-function"
end</p></pre></pre></div></p></div><p>Instead, methods must be included as object fields, where they can then be
bound and invoked.  A method value can be used in multiple objects:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  m = method(self): self.x end
  o = { a-method-name: m, x: 20 }
  o2 = { a-method-name: m, x: 30 }
  o.m() is 20
  o2.m() is 30
end</p></pre></pre></div></p></div><h5>2.1.9.4<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._app-expr)))"></a>&#8249;app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._app-args%29%29%29" data-pltdoc="x">&#8249;app-args&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._app-args)))"></a>&#8249;app-args&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-arg-elt%29%29%29" data-pltdoc="x">&#8249;app-arg-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._app-arg-elt)))"></a>&#8249;app-arg-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">,</span></p></blockquote><p>An application expression is an expression followed by a comma-separated list
of arguments enclosed in parentheses.  It first evaluates the arguments in
left-to-right order, then evaluates the function position.  If the function
position is a function value, the number of provided arguments is checked
against the number of arguments that the function expects.  If they match, the
arguments names are bound to the provided values.  If they don&rsquo;t, an exception
is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>f(1) # This is the function application expression f(1)
f (1) # This is the id-expr f, followed by the paren-expr (1)
# The second form yields a well-formedness error that there
# are two expressions on the same line</p></pre></pre><h5>2.1.9.5<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f(v, w, x, y, z): ... end</p></pre></pre><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>call-f-with-123 = lam(y, z): f(1, 2, 3, y, z) end</p></pre></pre><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>call-f-with-123 = f(1, 2, 3, _, _) # same as the fun expression above</p></pre></pre><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an lambda expression
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works
with operators.  For example, the following are two ways to sum a list
of numbers:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>[list: 1, 2, 3, 4].foldl(lam(a, b): a + b end, 0)

[list: 1, 2, 3, 4].foldl(_ + _, 0)</p></pre></pre><p>Likewise, the following are two ways to compare two lists for
equality:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>list.map_2(lam(x, y): x == y end, first-list, second-list)

list.map_2(_ == _, first-list, second-list)</p></pre></pre><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
check blocks, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>_ + _ + _</p></pre></pre><p>desugars to</p><pre class="pyret-block"><pre class="pyret-highlight"><p>lam(z):
  (lam(x, y): x + y end) + z
end</p></pre></pre><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>lam(x, y, z): x + y + z end</p></pre></pre><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>2.1.9.6<tt>&nbsp;</tt><a name="(part._s~3acannonball-expr)"></a>Chaining Application</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._chain-app-expr)))"></a>&#8249;chain-app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">^</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The expression <span class="pyret-highlight"><span class="stt">e1 ^ e2</span></span> is equivalent to <span class="pyret-highlight"><span class="stt">e2(e1)</span></span>.  It&rsquo;s just
another way of writing a function application to a single argument.</p><p>Sometimes, composing functions doesn&rsquo;t produce readable code.  For example, if
say we have a <span class="pyret-highlight"><span class="stt">Tree</span></span> datatype, and we have an <span class="pyret-highlight"><span class="stt">add</span></span> operation on
it, defined via a function.  To build up a tree with a series of adds, we&rsquo;d
write something like:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = add(add(add(add(empty-tree, 1), 2), 3), 4)</p></pre></pre><p>Or maybe</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t1 = add(empty-tree, 1)
t2 = add(t1, 2)
t3 = add(t2, 3)
t  = add(t3, 4)</p></pre></pre><p>If <span class="pyret-highlight"><span class="stt">add</span></span> were a method, we could write:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree.add(1).add(2).add(3).add(4)</p></pre></pre><p>which would be more readable, but since <span class="pyret-highlight"><span class="stt">add</span></span> is a function, this doesn&rsquo;t
work.</p><p>In this case, we can write instead:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree ^ add(_, 1) ^ add(_, 2) ^ add(_, 3)</p></pre></pre><p>This uses <a href="#%28part._s~3acurried-apply-expr%29" data-pltdoc="x">curried application</a> to create a
single argument function, and chaining application to apply it.  This can be
more readable across several lines of initialization as well, when compared to
composing &#8220;inside-out&#8221; or using several intermediate names:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree
  ^ add(_, 1)
  ^ add(_, 2)
  ^ add(_, 3)
  # and so on</p></pre></pre><h5>2.1.9.7<tt>&nbsp;</tt><a name="(part._s~3ainst-expr)"></a>Instantiation Expressions</h5><p>Functions may be defined with parametric signatures.  Calling those functions
does not require specifying the type parameter, but supplying it might aid in
readability, or may aid the static type checker.  You can supply the type
arguments just between the function name and the left-paren of the function
call.  Spaces are not permitted before the left-angle bracket or after the
right-angle bracket</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._inst-expr)))"></a>&#8249;inst-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">&lt;</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-lit">&gt;</span></p></blockquote><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>fun is-even(n :: Number) -&gt; Boolean: num-modulo(n, 2) == 0 end
check:
  map&lt;Number, Boolean&gt;(is-even, [list: 1, 2, 3]) is [list: false, true, false]
end</p></pre></pre></div></p></div><h5>2.1.9.8<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is a series of expressions joined by binary operators. An expression itself
is also a binary operator expression.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._binop-expr)))"></a>&#8249;binop-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit bnf-unknown">BINOP</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span></p></blockquote><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The <span class="pyret-highlight"><span class="stt">==</span></span> and <span class="pyret-highlight"><span class="stt">=~</span></span> operators also call methods, but are
somewhat more complex.  They are documented in detail in <a href="equality.html" data-pltdoc="x">equality</a>.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</div></p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr></table></p><p>For the primitive strings and numbers, the operation happens internally.  For
all object or data values, the operator looks for the method appropriate method
and calls it.</p><h5>2.1.9.9<tt>&nbsp;</tt><a name="(part._s~3atuple-expr)"></a>Tuple Expressions</h5><p>Tuples are an immutable, fixed-length collection of expressions indexed by non-negative integers:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._tuple-expr)))"></a>&#8249;tuple-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-fields%29%29%29" data-pltdoc="x">&#8249;tuple-fields&#8250;</a> <span class="bnf-lit">}</span>
<a name="(elem._(bnf-prod._(.Pyret._tuple-fields)))"></a>&#8249;tuple-fields&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">;</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">;</span><span class="bnf-meta">]</span></p></blockquote><p>A semicolon-separated sequence of fields enclosed in <span class="stt">{}</span> creates a tuple.</p><h5>2.1.9.10<tt>&nbsp;</tt><a name="(part._s~3atuple-get-expr)"></a>Tuple Access Expressions</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._tuple-get)))"></a>&#8249;tuple-get&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit">{</span> <span class="bnf-lit bnf-unknown">NUMBER</span> <span class="bnf-lit">}</span></p></blockquote><p>A tuple-get expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
does one of three things:</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A static well-formedness error is raised if the index is
negative</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><ul><li><p>Raises an exception, if <span class="stt">expr</span> is not a tuple</p></li><li><p>Raises an exception, if <span class="stt">NUMBER</span> is equal to or greater than the length of the given tuple</p></li><li><p>Evaluates the expression, returning the <span class="stt">val</span> at the given index.  The first index is <span class="pyret-highlight"><span class="stt">0</span></span></p></li></ul></div></p><p>For example:</p><pre class="pyret-block"><pre class="pyret-highlight good-ex"><p>check:
  t = {"a";"b";true}
  t.{0} is "a"
  t.{1} is "b"
  t.{2} is true
end</p></pre></pre><p>Note that the index is restricted <span style="font-style: italic">syntactically</span> to being a number.  So this program is a parse error:</p><pre class="pyret-block"><pre class="pyret-highlight bad-ex"><p>t = {"a";"b";"c"}
t.{1 + 1}</p></pre></pre><p>This restriction ensures that tuple access is typable.</p><h5>2.1.9.11<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._obj-expr)))"></a>&#8249;obj-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span><span class="bnf-meta"> | </span><span class="bnf-lit">{</span> <span class="bnf-lit">}</span>
<a name="(elem._(bnf-prod._(.Pyret._fields)))"></a>&#8249;fields&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-field%29%29%29" data-pltdoc="x">&#8249;list-field&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">,</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._list-field)))"></a>&#8249;list-field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._field)))"></a>&#8249;field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a>
          <span class="bnf-meta"> | </span><span class="bnf-lit">method</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._key)))"></a>&#8249;key&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field. A method field</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">"method" key fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key ":" "method" fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><p>The fields are evaluated in the order they appear.  If the same field appears
more than once, it is a compile-time error.</p><h5>2.1.9.12<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._dot-expr)))"></a>&#8249;dot-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of three things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><pre class="pyret-block"><pre class="pyret-highlight"><p>m = method(self, x): body end</p></pre></pre><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>(lam(self): lam(x): body end end)(v)</p></pre></pre><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>o = { method m(self, x): self.y + x end, y: 22 }
check:
  the-m-method-closed-over-o = o.m
  the-m-method-closed-over-o(5) is 27
end</p></pre></pre></li></ul><h5>2.1.9.13<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._extend-expr)))"></a>&#8249;extend-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span></p></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  o = {x : "original-x", y: "original-y"}
  o2 = o.{x : "new-x", z : "new-z"}
  o2.x is "new-x"
  o2.y is "original-y"
  o2.z is "new-z"
end</p></pre></pre><h5>2.1.9.14<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><p>An if expression has a number of test conditions and an optional else case.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._if-expr)))"></a>&#8249;if-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._else-if%29%29%29" data-pltdoc="x">&#8249;else-if&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">else:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._else-if)))"></a>&#8249;else-if&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">else if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>For example, this if expression has an "else:"</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre></pre><p>This one does not:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
end</p></pre></pre><p>Both are valid.  The conditions are tried in order, and the block corresponding
to the first one to return <span class="pyret-highlight"><span class="stt">true</span></span> is evaluated.  If no condition matches,
the else branch is evaluated if present.  If no condition matches and no else
branch is present, an error is thrown.  If a condition evaluates to a value
other than <span class="pyret-highlight"><span class="stt">true</span></span> or <span class="pyret-highlight"><span class="stt">false</span></span>, a runtime error is thrown.</p><h5>2.1.9.15<tt>&nbsp;</tt><a name="(part._s~3aask-expr)"></a>Ask Expressions</h5><p>An <span class="pyret-highlight"><span class="stt">ask</span></span> expression is a different way of writing an <span class="pyret-highlight"><span class="stt">if</span></span>
expression that can be easier to read in some cases.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._ask-expr)))"></a>&#8249;ask-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">ASK</span> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-branch%29%29%29" data-pltdoc="x">&#8249;ask-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">otherwise:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._ask-branch)))"></a>&#8249;ask-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">then:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>This ask expression:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>ask:
  | x == 0 then: 1
  | x &gt; 0 then: x
  | otherwise: x * -1
end</p></pre></pre><p>is equivalent to</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre></pre><p>Similar to <span class="pyret-highlight"><span class="stt">if</span></span>, if an <span class="pyret-highlight"><span class="stt">otherwise:</span></span> branch isn&rsquo;t specified and no
branch matches, a runtime error results.</p><h5>2.1.9.16<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._cases-expr)))"></a>&#8249;cases-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">cases</span> <span class="bnf-lit">(</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a> <span class="bnf-lit">)</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-branch%29%29%29" data-pltdoc="x">&#8249;cases-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">else</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._cases-branch)))"></a>&#8249;cases-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-meta">[</span><a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._args%29%29%29" data-pltdoc="x">&#8249;args&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>The <span class="pyret-highlight"><span class="stt">check-ann</span></span> must be a type, like <a href="lists.html#%28part._lists_.List%29" data-pltdoc="x"><span class="stt">List</span></a>.  Then
<span class="pyret-highlight"><span class="stt">expr</span></span> is evaluated and checked against the given annotation.  If
it has the right type, the cases are then checked.</p><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  In the branch that matches, the fields of the
variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand side
of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception results
if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a runtime error results.</p><p>For example, some cases expression on lists looks like:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  result = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | link(f, r) =&gt; "link"
  end
  result is "link"

  result2 = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result2 is else

  result3 = cases(List) empty:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result3 is "empty"
end</p></pre></pre><p>If a field of the variant is a tuple, it can also be bound using a tuple binding.</p><p>For example, a cases expression on a list with tuples looks like:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  result4 = cases(List) [list: {"a"; 1}, {"b"; 2}, {"c"; 3}]:
    | empty =&gt; "empty"
    | link({x;y}, r) =&gt; x
    | else =&gt; "else"
  end

  result4 is "a"
end</p></pre></pre></div></p></div><h5>2.1.9.17<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._for-expr)))"></a>&#8249;for-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">for</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind-elt%29%29%29" data-pltdoc="x">&#8249;for-bind-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._return-ann%29%29%29" data-pltdoc="x">&#8249;return-ann&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind-elt)))"></a>&#8249;for-bind-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind)))"></a>&#8249;for-bind&#8250;<span class="bnf-meta">:</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a> <span class="bnf-lit">from</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><pre class="pyret-block"><pre class="pyret-highlight"><p>for fexpr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:
  block
end</p></pre></pre><p>is equivalent to:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>fexpr(lam(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</p></pre></pre><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>for fold(sum from 0, number from [list: 1,2,3,4]):
  sum + number
end

fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])</p></pre></pre><h5>2.1.9.18<tt>&nbsp;</tt><a name="(part._s~3atemplate-expr)"></a>Template (...) Expressions</h5><p>A template expression is three dots in a row:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._template-expr)))"></a>&#8249;template-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">...</span></p></blockquote><p>It is useful for a placeholder for other expressions in code-in-progress.  When
it is evaluated, it raises a runtime exception that indicates the expression it
is standing in for isn&rsquo;t yet implemented:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>fun list-sum(l :: List&lt;Number&gt;) -&gt; Number:
  cases(List&lt;Number&gt;) l:
    | empty =&gt; 0
    | link(first, rest) =&gt; first + ...
  end
end
check:
  list-sum(empty) is 0
  list-sum(link(1, empty)) raises "template-not-finished"
end</p></pre></pre></div></p></div><p>This is handy for starting a function (especially one with many cases) with
some tests written and others to be completed.</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>These other positions for <span class="stt">...</span> may be included in the future.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">The <span class="stt">...</span> expression can only appear where <span style="font-style: italic">expressions</span> can appear.
So it is not allowed in binding positions or annotation positions.  These are
not allowed:</div></p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f(...): # parse error
  "todo"
end
x :: ... = 5 # parse error</p></pre></pre></div></p></div><p>Because templates are by definition unfinished, the presence of a
template expression in a block exempts that block from
<a href="Blocks.html#%28part._s~3ablocky-blocks%29" data-pltdoc="x">explicit-blockiness checking</a>.</p><h5>2.1.9.19<tt>&nbsp;</tt><a name="(part._s~3atables)"></a>Tables</h5><p>Tables are immutable datatypes consisting of a sequence of one or more
<span style="font-style: italic">rows</span>, which each contain an equal amount of entries in named locations
called <span style="font-style: italic">columns</span>.</p><p>Table expressions consist of a list of column names followed by one or more
rows of data:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-expr)))"></a>&#8249;table-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">table:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-headers%29%29%29" data-pltdoc="x">&#8249;table-headers&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-rows%29%29%29" data-pltdoc="x">&#8249;table-rows&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._table-headers)))"></a>&#8249;table-headers&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><span class="bnf-meta">[</span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-header%29%29%29" data-pltdoc="x">&#8249;table-header&#8250;</a> <span class="bnf-lit">,</span><span class="bnf-meta">]</span><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-header%29%29%29" data-pltdoc="x">&#8249;table-header&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._table-header)))"></a>&#8249;table-header&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-meta">[</span><span class="bnf-lit">::</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._table-rows)))"></a>&#8249;table-rows&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-row%29%29%29" data-pltdoc="x">&#8249;table-row&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-row%29%29%29" data-pltdoc="x">&#8249;table-row&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._table-row)))"></a>&#8249;table-row&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">row:</span> <span class="bnf-meta">(</span><span class="bnf-meta">[</span><a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">,</span><span class="bnf-meta">]</span><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>It is a well-formedness error for a table to have no rows or
no columns.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>my-table = table: name :: String, age :: Number
  row: "Bob", 12
  row: "Alice", 17
  row: "Eve", 13
end</p></pre></pre></div></p></div><p>Note that <span class="pyret-highlight"><span class="stt">my-tables</span></span> is referred to in many of the
following examples.</p><h5>2.1.9.19.1<tt>&nbsp;</tt><a name="(part._s~3atables~3aselect)"></a>Selecting Table Rows</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-select)))"></a>&#8249;table-select&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">select</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <span class="bnf-lit bnf-unknown">NAME</span><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-lit">from</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p><div class="SIntrapara">Selections are ways to pick only certain columns out from tables. For
example, one might only be interested in the names of the people contained
within <span class="pyret-highlight"><span class="stt">my-table</span></span>:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>names-only = select name from my-table end
check:
  names-only is table: name
    row: "Bob"
    row: "Alice"
    row: "Eve"
  end
end</p></pre></pre></div></p><h5>2.1.9.19.2<tt>&nbsp;</tt><a name="(part._s~3atables~3afilter)"></a>Filtering Table Rows</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-sieve)))"></a>&#8249;table-sieve&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">sieve</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">using</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>The <span class="pyret-highlight"><span class="stt">sieve</span></span> mechanism allows for filtering out rows of tables based
on some criteria. The <span class="pyret-highlight"><span class="stt">using</span></span> keyword specifies which columns may be
used in the body of the <span class="pyret-highlight"><span class="stt">sieve</span></span> expression.</p><p><div class="SIntrapara">For instance, we can find the individuals in <span class="pyret-highlight"><span class="stt">my-table</span></span> who are old
enough to drive in the United States. The following would be incorrect, since
the names being used in the expression body must follow <span class="pyret-highlight"><span class="stt">using</span></span>:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight bad-ex"><p>can-drive = sieve my-table using name:
  # age is not visible inside of this expression
  age &gt;= 16
end</p></pre></pre></div><div class="SIntrapara">Instead, this would be correct:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight good-ex"><p>can-drive = sieve my-table using age:
  age &gt;= 16
end
check:
  can-drive is table: name, age
    row: "Alice", 17
  end
end</p></pre></pre></div></p><h5>2.1.9.19.3<tt>&nbsp;</tt><a name="(part._s~3atables~3aorder)"></a>Sorting Table Rows</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-order)))"></a>&#8249;table-order&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">order</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._column-order%29%29%29" data-pltdoc="x">&#8249;column-order&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._column-order)))"></a>&#8249;column-order&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">ascending</span><span class="bnf-meta"> | </span><span class="bnf-lit">descending</span></p></blockquote><p>Since a table consists of a sequence of rows, one may desire to arrange
those rows in some particular order. This can be done with any column whose
type supports the use of <span class="pyret-highlight"><span class="stt">&lt;</span></span> and <span class="pyret-highlight"><span class="stt">&gt;</span></span> by using an <span class="pyret-highlight"><span class="stt">order</span></span>
expression:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>age-ordered = order my-table:
  age descending
end
check:
  age-ordered is table: name, age
    row: "Alice", 17
    row: "Eve", 13
    row: "Bob", 12
  end
end</p></pre></pre><h5>2.1.9.19.4<tt>&nbsp;</tt><a name="(part._s~3atables~3atransform)"></a>Transforming Table Rows</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-transform)))"></a>&#8249;table-transform&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">transform</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">using</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._transform-fields%29%29%29" data-pltdoc="x">&#8249;transform-fields&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._transform-fields)))"></a>&#8249;transform-fields&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._transform-field%29%29%29" data-pltdoc="x">&#8249;transform-field&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._transform-field%29%29%29" data-pltdoc="x">&#8249;transform-field&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">,</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._transform-field)))"></a>&#8249;transform-field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The <span class="pyret-highlight"><span class="stt">transform</span></span> expression allows the changing of columns within a
table, similar to the <span class="pyret-highlight"><span class="stt">map</span></span> function over lists (and, just like
<span class="pyret-highlight"><span class="stt">map</span></span>, <span class="pyret-highlight"><span class="stt">transform</span></span> expressions do not mutate the table, but
instead return a new one).</p><p><div class="SIntrapara">Suppose we find out that <span class="pyret-highlight"><span class="stt">my-table</span></span> is wrong and everyone is actually
a year older than it says they are. We can fix our data as follows:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>age-fixed = update my-table using age:
  age: age + 1
end
check:
  age-fixed is table: name, age
    row: "Bob", 13
    row: "Alice", 18
    row: "Eve", 14
  end
end</p></pre></pre></div></p><h5>2.1.9.19.5<tt>&nbsp;</tt><a name="(part._s~3atables~3aextract)"></a>Extracting Table Columns</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-extract)))"></a>&#8249;table-extract&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">extract</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">from</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>A large number of Pyret modules work on lists instead of tables, so it
may be desired to pull the contents of one column of a table as a list to
use it elsewhere. The <span class="pyret-highlight"><span class="stt">extract</span></span> mechanism allows this ability, and
serves as the primary "link" between processing tabular data and non-tabular
Pyret functions.</p><p><div class="SIntrapara">Suppose, for example, we wanted just the names of each person in
<span class="pyret-highlight"><span class="stt">my-table</span></span>. We could pull those names out as follows:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>name-list = select name from my-table end
check:
  name-list is [list: "Bob", "Alice", "Eve"]
end</p></pre></pre></div></p><h5>2.1.9.19.6<tt>&nbsp;</tt><a name="(part._s~3atables~3aextend)"></a>Adding Table Columns</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._table-extend)))"></a>&#8249;table-extend&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">extend</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">using</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><span class="bnf-meta">[</span><a href="#%28elem._%28bnf-prod._%28.Pyret._table-extend-field%29%29%29" data-pltdoc="x">&#8249;table-extend-field&#8250;</a> <span class="bnf-lit">,</span><span class="bnf-meta">]</span><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-extend-field%29%29%29" data-pltdoc="x">&#8249;table-extend-field&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._table-extend-field)))"></a>&#8249;table-extend-field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">::</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a>
                                    <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">::</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p><div class="SIntrapara">There are two types of extensions which can be made to tables: "mapping" and
"reducing" columns. A "mapping" column is one whose contents depend only on
the row it is being added to. An example of this would be a column which tells
whether the <span class="pyret-highlight"><span class="stt">age</span></span> field of a given row in <span class="pyret-highlight"><span class="stt">my-table</span></span> indicates
that the person in that row can drive in the United States or not (i.e.
whether that person is at least 16):
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>can-drive-col = extend my-table using age:
  can-drive: age &gt;= 16
end
check:
  can-drive-col is table: name, age, can-drive
    row: "Bob", 12, false
    row: "Alice", 17, true
    row: "Eve", 13, false
  end
end</p></pre></pre></div></p><p>Note that just like in <a href="#%28part._s~3atables~3atransform%29" data-pltdoc="x"><span class="pyret-highlight"><span class="stt">transform</span></span></a>, it
is required to specify which columns will be used in the body of the
<span class="pyret-highlight"><span class="stt">extend</span></span> expression using the <span class="pyret-highlight"><span class="stt">using</span></span> keyword.</p><p><div class="SIntrapara">Conversely, a "reducing" column is one whose information is computed from the
row it is being added to <span style="font-style: italic">and the rows above that row</span>. For example, given
<span class="pyret-highlight"><span class="stt">can-drive-col</span></span> from the previous example, suppose we would like to
keep a running total of how many people are able to drive. Importing the
<span class="stt">tables</span> module allows us to do this:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>import tables as TS
num-can-drive-col = extend my-table using can-drive:
  num-can-drive: TS.running-fold({(acc, cur): acc + (if cur: 1 else: 0 end)})
end
check:
  num-can-drive-col = table: name, age, can-drive, num-can-drive
    row: "Bob", 12, false, 0
    row: "Alice", 17, true, 1
    row: "Eve", 13, false, 1
  end
end</p></pre></pre></div></p><p><div class="SIntrapara">While the reducers found in the <span class="stt">tables</span> module should cover most all
use cases, there may be times when one would like to create a reducer of their
own. To do so, one must construct an object of the following type:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>type Reducer&lt;Acc, InVal, OutVal&gt; = {
  one :: (InVal -&gt; {Acc; OutVal}),
  reduce :: (Acc, InVal -&gt; {Acc; OutVal})
}</p></pre></pre></div></p><p>Reducers are essentially descriptions of folds (in the list <span class="pyret-highlight"><span class="stt">fold</span></span>
sense) over table columns. Note that one can reduce over multiple columns
as well, in which case the reducer will receive a tuple of values per row
instead of the usual one per row. The way reducers are called by the language
runtime is as follows: the value(s) from the first row are passed to the
reducer&rsquo;s <span class="pyret-highlight"><span class="stt">.one</span></span> method, which should return a tuple containing both
any accumulated information needed for the fold and the value which should
be placed in the new column in that row. The remaining rows are then
sequentially populated using the reducer&rsquo;s <span class="pyret-highlight"><span class="stt">.reduce</span></span> method, which is
identical to the <span class="pyret-highlight"><span class="stt">.one</span></span> method except that it receives an additional
argument which is the previously mentioned accumulated information from the
previous row.</p><p><div class="SIntrapara">To illustrate, a <span class="pyret-highlight"><span class="stt">running-mean</span></span> reducer which is equivalent to the
one provided by the <span class="stt">tables</span> module could be implemented as follows:
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>import tables as TS
running-mean :: TS.Reducer&lt;{Number; Number}, Number, Number&gt; = {
  one: lam(n): {{n; 1}; n} end,
  reduce: lam({sum; count}, n): { {sum + n; count + 1}; (sum + n) / (count + 1) }
}</p></pre></pre></div></p><h5>2.1.9.20<tt>&nbsp;</tt><a name="(part._s~3atable-loading)"></a>Table Loading Expressions</h5><p><div class="SIntrapara">A table loading expression constructs a table using a data source and
zero or more data sanitizers:
</div><div class="SIntrapara"><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._load-table-expr)))"></a>&#8249;load-table-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">load-table</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._table-headers%29%29%29" data-pltdoc="x">&#8249;table-headers&#8250;</a> <span class="bnf-meta">[</span><a href="#%28elem._%28bnf-prod._%28.Pyret._load-table-specs%29%29%29" data-pltdoc="x">&#8249;load-table-specs&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._load-table-specs)))"></a>&#8249;load-table-specs&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._load-table-spec%29%29%29" data-pltdoc="x">&#8249;load-table-spec&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._load-table-spec%29%29%29" data-pltdoc="x">&#8249;load-table-spec&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._load-table-spec)))"></a>&#8249;load-table-spec&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">source:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a>
                              <span class="bnf-meta"> | </span><span class="bnf-lit">sanitize</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">using</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></p></blockquote></div></p><p>Table loading expressions allow for the importing of tables from the
outside world into Pyret. Currently, only Google Sheets is supported.
In addition to data sources, the notion of <span style="font-style: italic">sanitizers</span> is used. These
are used to properly load each entry of the table as the correct type;
for example, the <span class="pyret-highlight"><span class="stt">string-sanitizer</span></span> in the <span class="stt">data-source</span> module
causes each item in its column to be loaded as a string (if it is not a
string, it is first converted to one). This is illustrated by the following
example:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>import data-source as DS
import gdrive-sheets as GS
music-ssheet = GS.load-spreadsheet("&lt;some-spreadsheet-id&gt;")

music = load-table: artist :: String, title :: String, year, sales :: Number
  source: music-ssheet.sheet-by-name("Sales", false)
  sanitize artist using DS.string-sanitizer
  sanitize title using DS.string-sanitizer
  sanitize year using DS.strict-num-sanitizer
  sanitize sales using DS.strict-num-sanitizer
end</p></pre></pre></div></p></div><p>In general, it is <span style="font-style: italic">safest</span> to sanitize <span style="font-style: italic">every</span> input column, since it
is the only way to guarantee that the data source will not guess the column&rsquo;s
type incorrectly.</p><p>Data sources are currently an internal concept to Pyret, so no public
interface for creating them is supported.</p><p>While the <span class="stt">data-source</span> library provides sanitizers which should cover
most use cases, there may be times when one would like to create a custom
data sanitizer. To do so, one must simply create a function which conforms
to the <span class="pyret-highlight"><span class="stt">Sanitizer&lt;A,B&gt;</span></span> type in the <span class="stt">data-source</span> module.</p><h5>2.1.9.21<tt>&nbsp;</tt><a name="(part._s~3areactor-expr)"></a>Reactor Expressions</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._reactor-expr)))"></a>&#8249;reactor-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">reactor</span> <span class="bnf-lit">:</span> <span class="bnf-lit">init</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-meta">[</span><span class="bnf-lit">,</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._option-name%29%29%29" data-pltdoc="x">&#8249;option-name&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a><span class="bnf-meta">]</span><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._option-name)))"></a>&#8249;option-name&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">on-tick</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">on-mouse</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">on-key</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">to-draw</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">stop-when</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">title</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">close-when-stop</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">seconds-per-tick</span></p></blockquote><p>Reactors are described in detail in <a href="reactors.html#%28part._s~3areactors%29" data-pltdoc="x">Creating Reactors</a>.</p><h5>2.1.9.22<tt>&nbsp;</tt><a name="(part._s~3areference-fields)"></a>Mutable fields</h5><p><div class="SIntrapara">Pyret allows creating data definitions whose fields are mutable.  Accordingly,
it provides syntax for accessing and modifying those fields.
</div><div class="SIntrapara"><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._get-bang-expr)))"></a>&#8249;get-bang-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">!</span> <span class="bnf-lit bnf-unknown">NAME</span>
<a name="(elem._(bnf-prod._(.Pyret._update-expr)))"></a>&#8249;update-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">!</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span></p></blockquote></div></p><p>By analogy with how <a href="#%28elem._%28bnf-prod._%28.Pyret._dot-expr%29%29%29" data-pltdoc="x">&#8249;dot-expr&#8250;</a> accesses normal fields,
<a href="#%28elem._%28bnf-prod._%28.Pyret._get-bang-expr%29%29%29" data-pltdoc="x">&#8249;get-bang-expr&#8250;</a> accesses mutable fields &#8212;<wbr></wbr> but more emphatically so,
because mutable fields, by their nature, might change.  Dot-access to mutable
fields also works, but does not return the field&rsquo;s value: it returns the
reference itself, which is a Pyret value that&rsquo;s mostly inert and difficult to
work with outside the context of its host object.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>data MutX:
  | mut-x(ref x, y)
end

ex1 = mut-x(1, 2)

check:
  ex1!x is 1      # this access the value inside the reference
  ex1.x is-not 1  # this does not
end</p></pre></pre></div></p></div><p>To update a reference value, we use syntax similar to <a href="#%28elem._%28bnf-prod._%28.Pyret._extend-expr%29%29%29" data-pltdoc="x">&#8249;extend-expr&#8250;</a>,
likewise made more emphatic:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>ex1!{x: 42}
check:
  ex1!x is 42
end</p></pre></pre></div></p></div><h5>2.1.9.23<tt>&nbsp;</tt><a name="(part._s~3aconstruct-expr)"></a>Construction expressions</h5><p><div class="SIntrapara">Individual Pyret data values are syntactically simple to construct: they look
similar to function calls.  But arbitrarily-sized data is not as obvious.  For
instance, we could write
</div><div class="SIntrapara"><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>link(1, link(2, link(3, link(4, empty))))</p></pre></pre></div></p></div></div><div class="SIntrapara">to construct a 4-element list of numbers, but this gets tiresome quite
quickly.  Many languages provide built-in syntactic support for constructing
lists, but in Pyret we want all data types to be treated equally.  Accordingly,
we can write the above example as
</div><div class="SIntrapara"><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>[list: 1, 2, 3, 4]</p></pre></pre></div></p></div></div><div class="SIntrapara">where <span style="font-style: italic"><span class="pyret-highlight"><span class="stt">list</span></span> is not a syntactic keyword</span> in the language.  Instead,
this is one example of a <span style="font-style: italic">construction expression</span>, whose syntax is simply
</div><div class="SIntrapara"><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._construct-expr)))"></a>&#8249;construct-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">[</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._construct-args%29%29%29" data-pltdoc="x">&#8249;construct-args&#8250;</a> <span class="bnf-lit">]</span>
<a name="(elem._(bnf-prod._(.Pyret._construct-args)))"></a>&#8249;construct-args&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span><span class="bnf-meta">]</span></p></blockquote></div></p><p>Pyret defines several of these constructors for you: lists, sets, arrays, and
string-dictionaries all have the same syntax.</p><p><div class="SIntrapara">The expression before the initial colon is a Pyret object that has a particular
set of methods available.  Users can define their own constructors as well.
</div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>type Constructor&lt;A&gt; = {
  make0 :: ( -&gt; A),
  make1 :: (Any -&gt; A),
  make2 :: (Any, Any -&gt; A),
  make3 :: (Any, Any, Any -&gt; A),
  make4 :: (Any, Any, Any, Any -&gt; A),
  make5 :: (Any, Any, Any, Any, Any -&gt; A)
  make  :: (RawArray&lt;Any&gt; -&gt; A),
}</p></pre></pre></div><div class="SIntrapara">When Pyret encounters a construction expression, it will call the
appropriately-numbered method on the constructor objects, depending on the
number of arguments it received.</div></p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>weird :: Constructor&lt;String&gt; = {
  make0: lam(): "nothing at all" end,
  make1: lam(a): "just " + tostring(a) end,
  make2: lam(a, b): tostring(a) + " and " + tostring(b) end,
  make3: lam(a, b, c): "several things" end,
  make4: lam(a, b, c, d): "four things" end,
  make5: lam(a, b, c, d, e): "five things" end,
  make : lam(args): "too many things" end
}
check:
  [weird: ] is "nothing at all"
  [weird: true] is "just true"
  [weird: 5, 6.24] is "5 and 6.24"
  [weird: true, false, 5] is "several things"
  [weird: 1, 2, 3, 4] is "four things"
  [weird: 1, 1, 1, 1, 1] is "five things"
  [weird: "a", "b", "c", true, false, 5] is "too many things"
end</p></pre></pre></div></p></div><h5>2.1.9.24<tt>&nbsp;</tt><a name="(part._s~3abinding-expressions)"></a>Expression forms of bindings</h5><p>Every definition is Pyret is visible until the end of its scope, which is
usually the nearest enclosing block.  To limit that scope, you can wrap
definitions in explicit <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._user-block-expr%29%29%29" data-pltdoc="x">&#8249;user-block-expr&#8250;</a>s, but this is sometimes awkward to
read.  Pyret allows for three additional forms that combine bindings with
expression blocks in a manner that is sometimes more legible:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._multi-let-expr)))"></a>&#8249;multi-let-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">let</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._let-or-var%29%29%29" data-pltdoc="x">&#8249;let-or-var&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._let-or-var%29%29%29" data-pltdoc="x">&#8249;let-or-var&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._let-or-var)))"></a>&#8249;let-or-var&#8250;<span class="bnf-meta">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._let-decl%29%29%29" data-pltdoc="x">&#8249;let-decl&#8250;</a><span class="bnf-meta"> | </span><a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._var-decl%29%29%29" data-pltdoc="x">&#8249;var-decl&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._letrec-expr)))"></a>&#8249;letrec-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">letrec</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._let-decl%29%29%29" data-pltdoc="x">&#8249;let-decl&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._let-decl%29%29%29" data-pltdoc="x">&#8249;let-decl&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._type-let-expr)))"></a>&#8249;type-let-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">type-let</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._type-let-or-newtype%29%29%29" data-pltdoc="x">&#8249;type-let-or-newtype&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">,</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._type-let-or-newtype%29%29%29" data-pltdoc="x">&#8249;type-let-or-newtype&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._type-let-or-newtype)))"></a>&#8249;type-let-or-newtype&#8250;<span class="bnf-meta">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._type-decl%29%29%29" data-pltdoc="x">&#8249;type-decl&#8250;</a><span class="bnf-meta"> | </span><a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._newtype-decl%29%29%29" data-pltdoc="x">&#8249;newtype-decl&#8250;</a></p></blockquote><p>These define their bindings only for the scope of the following block.  A
<a href="#%28elem._%28bnf-prod._%28.Pyret._multi-let-expr%29%29%29" data-pltdoc="x">&#8249;multi-let-expr&#8250;</a> defines a sequence of either let- or
variable-bindings, each of which are in scope for subsequent ones.  A
<a href="#%28elem._%28bnf-prod._%28.Pyret._letrec-expr%29%29%29" data-pltdoc="x">&#8249;letrec-expr&#8250;</a> defines a set of mutually-recursive let-bindings that may
refer to each other in a well-formed way (i.e., no definition may rely on other
definitions before they&rsquo;ve been fully evaluated).  These are akin to the
<a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._let-decl%29%29%29" data-pltdoc="x">&#8249;let-decl&#8250;</a> and <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._var-decl%29%29%29" data-pltdoc="x">&#8249;var-decl&#8250;</a> forms seen earlier, but with more
explicitly-visible scoping rules.</p><p>Finally, <a href="#%28elem._%28bnf-prod._%28.Pyret._type-let-expr%29%29%29" data-pltdoc="x">&#8249;type-let-expr&#8250;</a> defines local type aliases or new types, akin
to <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._type-stmt%29%29%29" data-pltdoc="x">&#8249;type-stmt&#8250;</a>.</p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sql</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.8 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.10 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>